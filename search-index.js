var searchIndex = {};
searchIndex["hvif_rs"] = {"doc":"This is documentation for the hvif_rs module","items":[[0,"types","hvif_rs","Types for HVIF images",null,null],[3,"HVIFImage","hvif_rs::types","A fully specified HVIF image",null,null],[12,"styles","","All styles belonging to this image",0,null],[12,"paths","","All paths belonging to this image",0,null],[12,"shapes","","All shapes belonging to this image",0,null],[3,"HVIFFlag","","Flags that modify the parsing of the following data",null,null],[0,"path","","Types for HVIF paths",null,null],[3,"HVIFPath","hvif_rs::types::path","An HVIF path, drawn between points",null,null],[12,"points","","A list of commands that represent the sequence of points for this path",1,null],[3,"HVIFPoint","","A simple 2D point in the XY plane, where each coordinate is a floating point value",null,null],[12,"x","","The x-coordinate",2,null],[12,"y","","The y-coordinate",2,null],[4,"HVIFPointCommand","","One or more points, and a command that specifies how the point/s are to be interpreted",null,null],[13,"HLine","","A horizontal line from the previous x-coordinate to this one",3,null],[12,"x","hvif_rs::types::path::HVIFPointCommand","target x-coordinate",3,null],[13,"VLine","hvif_rs::types::path","A vertical line from the previous y-coordinate to this one",3,null],[12,"y","hvif_rs::types::path::HVIFPointCommand","target y-coordinate",3,null],[13,"Line","hvif_rs::types::path","A straight line from the previous point to this one",3,null],[12,"point","hvif_rs::types::path::HVIFPointCommand","target point",3,null],[13,"Curve","hvif_rs::types::path","A cubic Bezier curve from the previous point to this one",3,null],[12,"point_in","hvif_rs::types::path::HVIFPointCommand","inital control point",3,null],[12,"point","","target point",3,null],[12,"point_out","","final control point",3,null],[11,"fmt","hvif_rs::types::path","",1,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[0,"shape","hvif_rs::types","Types for HVIF shapes",null,null],[3,"HVIFShape","hvif_rs::types::shape","An HVIF shape, consisting of a single style, one or more paths, and optional additional transformation data",null,null],[12,"style_index","","The index of the style used in the shape",4,null],[12,"path_indices","","The indices of the paths that use this shape&#39;s style",4,null],[12,"modifiers","","A list of any optional modifications to this shape",4,null],[3,"HVIFf24","","A temporary implementation of an f24 value, as three bytes",null,null],[12,"fst","","First (most significant) bits",5,null],[12,"snd","","Middle bits",5,null],[12,"thr","","Last (least significant) bits",5,null],[3,"HVIFMatrix","","A 2D affine transformation matrix\nAs per HVIF spec, consists of six f24 values",null,null],[12,"x1","","x1",6,null],[12,"y1","","y1",6,null],[12,"z1","","z1",6,null],[12,"x2","","x2",6,null],[12,"y2","","y2",6,null],[12,"z2","","z2",6,null],[4,"HVIFShapeModifier","","A modifier to an HVIF shape",null,null],[13,"HVIFTransformMatrix","","A single affine transformation matrix",7,null],[13,"HVIFHinting","","The shape uses hinting",7,null],[13,"HVIFLODScale","","Level of Detail scales\nRepresents the allowable scales at which this shape will appear correctly",7,null],[12,"min","hvif_rs::types::shape::HVIFShapeModifier","Minimum LOD for this shape",7,null],[12,"max","","Maximum LOD for this shape",7,null],[13,"HVIFTranslation","hvif_rs::types::shape","An optional linear translation of the shape (offset)",7,null],[13,"HVIFTransformerList","","A list of optional transformers",7,null],[4,"HVIFTransformer","","Some transformation on a basic HVIF shape",null,null],[13,"Affine","","An affine transformation using a single matrix",8,null],[13,"Contour","","?",8,null],[12,"width","hvif_rs::types::shape::HVIFTransformer","?",8,null],[12,"line_join","","?",8,null],[12,"miter_limit","","?",8,null],[13,"Perspective","hvif_rs::types::shape","?",8,null],[13,"Stroke","","?",8,null],[12,"width","hvif_rs::types::shape::HVIFTransformer","?",8,null],[12,"line_join","","?",8,null],[12,"line_cap","","?",8,null],[12,"miter_limit","","?",8,null],[11,"fmt","hvif_rs::types::shape","",4,null],[11,"fmt","","",7,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[0,"style","hvif_rs::types","Types for HVIF styles",null,null],[3,"HVIFGradient","hvif_rs::types::style","A gradient between mutiple aRGB colors",null,null],[12,"gradient_type","","The type of the gradient",9,null],[12,"colors","","A collection of the colors making up the gradient",9,null],[3,"HVIFGradientColor","","Color of a gradient, along with a stop offset",null,null],[12,"stop_offset","","The stop offset for this color - the &quot;position&quot; it holds relative to other colors in the gradient",10,null],[12,"alpha","","The alpha channel",10,null],[12,"red","","The red channel",10,null],[12,"green","","The green channel",10,null],[12,"blue","","The blue channel",10,null],[4,"HVIFStyle","","A single HVIF style",null,null],[13,"SolidColor","","A solid aRGB color",11,null],[12,"red","hvif_rs::types::style::HVIFStyle","red channel",11,null],[12,"green","","green channel",11,null],[12,"blue","","blue channel",11,null],[12,"alpha","","alpha channel",11,null],[13,"Gradient","hvif_rs::types::style","A gradient between multiple aRGB colors",11,null],[13,"SolidColorNoAlpha","","A solid opaque RGB color",11,null],[12,"red","hvif_rs::types::style::HVIFStyle","red channel",11,null],[12,"green","","green channel",11,null],[12,"blue","","blue channel",11,null],[13,"SolidGray","hvif_rs::types::style","A solid greyscale color with an alpha channel",11,null],[12,"value","hvif_rs::types::style::HVIFStyle","value on red, green, and blue channels",11,null],[12,"alpha","","alpha channel",11,null],[13,"SolidGrayNoAlpha","hvif_rs::types::style","A solid greyscale color without an alpha channel",11,null],[12,"value","hvif_rs::types::style::HVIFStyle","value on red, green, and blue channels",11,null],[4,"HVIFGradientType","hvif_rs::types::style","The type of a gradient - determines how the gradient renders spatially",null,null],[13,"Linear","","A linear gradient; follows a line from one point to another",12,null],[13,"Circular","","A circular gradient; changes radially from the center to the edge of a circular region",12,null],[13,"Diamond","","A diamond graident; changes linearly from the center to the edge of a diagonal region",12,null],[13,"Conic","","A conic gradient; changes angularly across a circular region",12,null],[13,"XY","","An XY gradient; changes linearly in both the X and Y directions",12,null],[13,"SqrtXY","","A square root XY gradient: changes quadratically in both the X and Y directions",12,null],[5,"gradient_type_from_u8","","Convert a u8 into a gradient type",null,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"fmt","","",11,null],[11,"fmt","","",9,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"fmt","","",10,null],[11,"clone","","",10,null],[17,"HVIF_GRADIENT_FLAG_TRANSFORM","hvif_rs::types","?",null,null],[17,"HVIF_GRADIENT_FLAG_NO_ALPHA","","The colors in this gradient have no alpha channel",null,null],[17,"HVIF_GRADIENT_FLAG_COLORS_16_BIT","","The colors in this gradient have a deeper color depth per channel of 16 bits, instead of 8",null,null],[17,"HVIF_GRADIENT_FLAG_GRAYS","","The colors in this gradient are all grayscale",null,null],[17,"HVIF_PATH_FLAG_CLOSED","","The path&#39;s last point is connected to its first point",null,null],[17,"HVIF_PATH_FLAG_USES_COMMANDS","","The path has a command section, and can use HLine and VLine commands",null,null],[17,"HVIF_PATH_FLAG_NO_CURVES","","The path is made up entirely of straight lines",null,null],[17,"HVIF_SHAPE_FLAG_TRANSFORM","","This shape uses an affine transformation matrix to translate, rotate, and scale itself",null,null],[17,"HVIF_SHAPE_FLAG_HINTING","","?",null,null],[17,"HVIF_SHAPE_FLAG_LOD_SCALE","","?",null,null],[17,"HVIF_SHAPE_FLAG_HAS_TRANSFORMERS","","?",null,null],[17,"HVIF_SHAPE_FLAG_TRANSLATION","","?",null,null],[11,"fmt","","",0,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"is_set_on","","Checks whether the flag is set on a byte",13,null],[0,"parser","hvif_rs","Parsers for HVIF images",null,null],[5,"hvif_image","hvif_rs::parser","Parses an entire HVIF image",null,null],[0,"style","","Parser for HVIF styles",null,null],[5,"hvif_style","hvif_rs::parser::style","Parses an HVIF style",null,null],[0,"path","hvif_rs::parser","Parser for HVIF paths",null,null],[5,"hvif_path","hvif_rs::parser::path","Parses an HVIF path",null,null],[0,"shape","hvif_rs::parser","Parser for HVIF shapes",null,null],[5,"hvif_shape","hvif_rs::parser::shape","Parses an HVIF shape",null,null],[0,"util","hvif_rs::parser","Utility parsers used throughout the HVIF format",null,null],[5,"hvif_point","hvif_rs::parser::util","Parses an HVIF point",null,null],[5,"hvif_path_coord","","Parses an HVIF coordinate",null,null],[5,"hvif_shape_matrix","","Parses an HVIF affine matrix",null,null],[5,"hvif_shape_f24","","Parses an HVIF 24-bit float",null,null]],"paths":[[3,"HVIFImage"],[3,"HVIFPath"],[3,"HVIFPoint"],[4,"HVIFPointCommand"],[3,"HVIFShape"],[3,"HVIFf24"],[3,"HVIFMatrix"],[4,"HVIFShapeModifier"],[4,"HVIFTransformer"],[3,"HVIFGradient"],[3,"HVIFGradientColor"],[4,"HVIFStyle"],[4,"HVIFGradientType"],[3,"HVIFFlag"]]};
searchIndex["nom"] = {"doc":"nom, eating data byte by byte","items":[[3,"ProducerRepeat","nom","ProducerRepeat takes a single value, and generates it at each step",null,null],[3,"MemProducer","","A MemProducer generates values from an in memory byte buffer",null,null],[3,"FileProducer","","",null,null],[3,"MapConsumer","","MapConsumer takes a function S -&gt; T and applies it on a consumer producing values of type S",null,null],[3,"ChainConsumer","","ChainConsumer takes a consumer C1 R -&gt; S, and a consumer C2 S -&gt; T, and makes a consumer R -&gt; T by applying C2 on C1&#39;s result",null,null],[4,"ErrorKind","","indicates which parser returned an error",null,null],[13,"Custom","","",0,null],[13,"Tag","","",0,null],[13,"MapRes","","",0,null],[13,"MapOpt","","",0,null],[13,"Alt","","",0,null],[13,"IsNot","","",0,null],[13,"IsA","","",0,null],[13,"SeparatedList","","",0,null],[13,"SeparatedNonEmptyList","","",0,null],[13,"Many0","","",0,null],[13,"Many1","","",0,null],[13,"ManyTill","","",0,null],[13,"Count","","",0,null],[13,"TakeUntilAndConsume","","",0,null],[13,"TakeUntil","","",0,null],[13,"TakeUntilEitherAndConsume","","",0,null],[13,"TakeUntilEither","","",0,null],[13,"LengthValue","","",0,null],[13,"TagClosure","","",0,null],[13,"Alpha","","",0,null],[13,"Digit","","",0,null],[13,"HexDigit","","",0,null],[13,"OctDigit","","",0,null],[13,"AlphaNumeric","","",0,null],[13,"Space","","",0,null],[13,"MultiSpace","","",0,null],[13,"LengthValueFn","","",0,null],[13,"Eof","","",0,null],[13,"ExprOpt","","",0,null],[13,"ExprRes","","",0,null],[13,"CondReduce","","",0,null],[13,"Switch","","",0,null],[13,"TagBits","","",0,null],[13,"OneOf","","",0,null],[13,"NoneOf","","",0,null],[13,"Char","","",0,null],[13,"CrLf","","",0,null],[13,"RegexpMatch","","",0,null],[13,"RegexpMatches","","",0,null],[13,"RegexpFind","","",0,null],[13,"RegexpCapture","","",0,null],[13,"RegexpCaptures","","",0,null],[13,"TakeWhile1","","",0,null],[13,"Complete","","",0,null],[13,"Fix","","",0,null],[13,"Escaped","","",0,null],[13,"EscapedTransform","","",0,null],[13,"TagStr","","",0,null],[13,"IsNotStr","","",0,null],[13,"IsAStr","","",0,null],[13,"TakeWhile1Str","","",0,null],[13,"NonEmpty","","",0,null],[13,"ManyMN","","",0,null],[13,"TakeUntilAndConsumeStr","","",0,null],[13,"TakeUntilStr","","",0,null],[13,"Not","","",0,null],[13,"Permutation","","",0,null],[13,"Verify","","",0,null],[4,"CompareResult","","indicates wether a comparison was successful, an error, or\nif more data was needed",null,null],[13,"Ok","","",1,null],[13,"Incomplete","","",1,null],[13,"Error","","",1,null],[4,"Needed","","Contains information on needed data if a parser returned `Incomplete`",null,null],[13,"Unknown","","needs more data, but we do not know how much",2,null],[13,"Size","","contains the required data size",2,null],[4,"IResult","","Holds the result of parsing functions",null,null],[13,"Done","","indicates a correct parsing, the first field containing the rest of the unparsed data, the second field contains the parsed data",3,null],[13,"Error","","contains a Err, an enum that can indicate an error code, a position in the input, and a pointer to another error, making a list of errors in the parsing tree",3,null],[13,"Incomplete","","Incomplete contains a Needed, an enum than can represent a known quantity of input data, or unknown",3,null],[4,"IError","","This is the same as IResult, but without Done",null,null],[13,"Error","","",4,null],[13,"Incomplete","","",4,null],[4,"Endianness","","Configurable endianness",null,null],[13,"Big","","",5,null],[13,"Little","","",5,null],[4,"Input","","",null,null],[13,"Element","","",6,null],[13,"Empty","","",6,null],[13,"Eof","","",6,null],[4,"ConsumerState","","Stores a consumer&#39;s current computation state",null,null],[13,"Done","","A value of type O has been produced",7,null],[13,"Error","","An error of type E has been encountered",7,null],[13,"Continue","","Continue applying, and pass a message of type M to the data source",7,null],[4,"Move","","",null,null],[13,"Consume","","indcates how much data was consumed",8,null],[13,"Seek","","indicates where in the input the consumer must seek",8,null],[13,"Await","","indicates more data is needed",8,null],[4,"FileProducerState","","",null,null],[13,"Normal","","",9,null],[13,"Error","","",9,null],[13,"Eof","","",9,null],[5,"slice_to_offsets","","",null,null],[5,"code_from_offset","","",null,null],[5,"reset_color","","",null,{"inputs":[{"name":"vec"}],"output":null}],[5,"write_color","","",null,{"inputs":[{"name":"vec"},{"name":"u8"}],"output":null}],[5,"print_codes","","",null,{"inputs":[{"name":"hashmap"},{"name":"hashmap"}],"output":{"name":"string"}}],[5,"error_to_u32","","",null,{"inputs":[{"name":"errorkind"}],"output":{"name":"u32"}}],[5,"tag_cl","","",null,null],[5,"print","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"begin","","",null,null],[5,"crlf","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"not_line_ending","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"line_ending","","Recognizes an end of line (both &#39;\\n&#39; and &#39;\\r\\n&#39;)",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"eol","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"is_alphabetic","","Tests if byte is ASCII alphabetic: A-Z, a-z",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","Tests if byte is ASCII digit: 0-9",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_hex_digit","","Tests if byte is ASCII hex digit: 0-9, A-F, a-f",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_oct_digit","","Tests if byte is ASCII octal digit: 0-7",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_space","","Tests if byte is ASCII space or tab",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"alpha","","Recognizes lowercase and uppercase alphabetic characters: a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"digit","","Recognizes numerical characters: 0-9",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"hex_digit","","Recognizes hexadecimal numerical characters: 0-9, A-F, a-f",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"oct_digit","","Recognizes octal characters: 0-7",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"alphanumeric","","Recognizes numerical and alphabetic characters: 0-9a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"space","","Recognizes spaces and tabs",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"multispace","","Recognizes spaces, tabs, carriage returns and line feeds",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"sized_buffer","","",null,null],[5,"be_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"be_u16","","Recognizes big endian unsigned 2 bytes integer",null,null],[5,"be_u32","","Recognizes big endian unsigned 4 bytes integer",null,null],[5,"be_u64","","Recognizes big endian unsigned 8 bytes integer",null,null],[5,"be_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"be_i16","","Recognizes big endian signed 2 bytes integer",null,null],[5,"be_i32","","Recognizes big endian signed 4 bytes integer",null,null],[5,"be_i64","","Recognizes big endian signed 8 bytes integer",null,null],[5,"le_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"le_u16","","Recognizes little endian unsigned 2 bytes integer",null,null],[5,"le_u32","","Recognizes little endian unsigned 4 bytes integer",null,null],[5,"le_u64","","Recognizes little endian unsigned 8 bytes integer",null,null],[5,"le_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"le_i16","","Recognizes little endian signed 2 bytes integer",null,null],[5,"le_i32","","Recognizes little endian signed 4 bytes integer",null,null],[5,"le_i64","","Recognizes little endian signed 8 bytes integer",null,null],[5,"be_f32","","Recognizes big endian 4 bytes floating point number",null,null],[5,"be_f64","","Recognizes big endian 8 bytes floating point number",null,null],[5,"le_f32","","Recognizes little endian 4 bytes floating point number",null,null],[5,"le_f64","","Recognizes little endian 8 bytes floating point number",null,null],[5,"hex_u32","","Recognizes a hex-encoded integer",null,null],[5,"non_empty","","Recognizes non empty buffers",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"rest","","Return the remaining input.",null,null],[5,"rest_s","","Return the remaining input, for strings.",null,{"inputs":[{"name":"str"}],"output":{"name":"iresult"}}],[5,"float","","Recognizes floating point number in a byte string and returs a f32",null,null],[5,"float_s","","Recognizes floating point number in a string and returs a f32",null,{"inputs":[{"name":"str"}],"output":{"name":"iresult"}}],[5,"double","","Recognizes floating point number in a byte string and returs a f64",null,null],[5,"double_s","","Recognizes floating point number in a string and returs a f64",null,{"inputs":[{"name":"str"}],"output":{"name":"iresult"}}],[5,"newline","","Matches a newline character &#39;\\n&#39;",null,null],[5,"tab","","Matches a tab character &#39;\\t&#39;",null,null],[5,"anychar","","",null,null],[5,"shift","","",null,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"hash","","",0,null],[11,"clone","","",0,null],[11,"description","","",0,null],[11,"fmt","","",1,null],[11,"eq","","",1,null],[0,"simple_errors","","Error management",null,null],[6,"Err","nom::simple_errors","",null,null],[11,"map_err","nom","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, N&gt;` by appling a function\nto a contained `Error` value, leaving `Done` and `Incomplete` value\nuntouched.",3,null],[11,"unwrap_err","","Unwrap the contained `Error(E)` value, or panic if the `IResult` is not\n`Error`.",3,null],[11,"to_full_result","","Convert the IResult to a std::result::Result",3,null],[11,"to_result","","Convert the IResult to a std::result::Result, or panic if the `IResult` is `Incomplete`",3,null],[11,"description","nom::simple_errors","",10,null],[11,"fmt","","",10,null],[11,"fmt","nom","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"clone","","",2,null],[11,"is_known","","",2,null],[11,"map","","Maps a `Needed` to `Needed` by appling a function to a contained `Size` value.",2,null],[11,"fmt","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"clone","","",4,null],[11,"is_done","","",3,null],[11,"is_err","","",3,null],[11,"is_incomplete","","",3,null],[11,"map","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, N, E&gt;` by appling a function\nto a contained `Done` value, leaving `Error` and `Incomplete` value\nuntouched.",3,null],[11,"map_inc","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, E&gt;` by appling a function\nto a contained `Incomplete` value, leaving `Done` and `Error` value\nuntouched.",3,null],[11,"unwrap","","Unwrap the contained `Done(I, O)` value, or panic if the `IResult` is not\n`Done`.",3,null],[11,"unwrap_inc","","Unwrap the contained `Incomplete(n)` value, or panic if the `IResult` is not\n`Incomplete`.",3,null],[11,"remaining_input","","",3,null],[11,"remaining_input","","",3,null],[11,"remaining_input","","",3,null],[11,"output","","",3,null],[11,"output","","",3,null],[11,"output","","",3,null],[0,"methods","","Method macro combinators",null,null],[0,"bits","","Bit level parsers and combinators",null,null],[11,"eq","","",5,null],[0,"whitespace","","Support for whitespace delimited formats",null,null],[5,"sp","nom::whitespace","",null,null],[11,"fmt","nom","",6,null],[11,"clone","","",6,null],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"map","","",7,null],[11,"flat_map","","",7,null],[11,"apply","","",11,null],[11,"new","","",12,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"apply","","",12,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"eq","","",9,null],[11,"fmt","","",13,null],[11,"new","","",13,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"state","","",13,null],[11,"refill","","",13,null],[11,"resize","","Resize the internal buffer, copy the data to the new one and returned how much data was copied",13,null],[11,"apply","","",13,null],[11,"new","","",14,{"inputs":[{"name":"c"},{"name":"f"}],"output":{"name":"mapconsumer"}}],[11,"handle","","",14,null],[11,"state","","",14,null],[11,"new","","",15,{"inputs":[{"name":"c1"},{"name":"c2"}],"output":{"name":"chainconsumer"}}],[11,"handle","","",15,null],[11,"state","","",15,null],[8,"Offset","","useful functions to calculate the offset between slices and show a hexdump of a slice",null,null],[10,"offset","","offset between the first byte of self and the first byte of the argument",16,null],[8,"HexDisplay","","",null,null],[10,"to_hex","","Converts the value of `self` to a hex dump, returning the owned\nstring.",17,null],[10,"to_hex_from","","Converts the value of `self` to a hex dump beginning at `from` address, returning the owned\nstring.",17,null],[8,"AsBytes","","",null,null],[10,"as_bytes","","",18,null],[8,"InputLength","","abstract method to calculate the input length",null,null],[10,"input_len","","calculates the input length, as indicated by its name,\nand the name of the trait itself",19,null],[8,"AsChar","","transforms common types to a char for basic token parsing",null,null],[10,"as_char","","makes a char from self",20,null],[10,"is_alpha","","tests that self is an alphabetic character",20,null],[10,"is_alphanum","","tests that self is an alphabetic character\nor a decimal digit",20,null],[10,"is_dec_digit","","tests that self is a decimal digit",20,null],[10,"is_hex_digit","","tests that self is an hex digit",20,null],[10,"is_oct_digit","","tests that self is an octal digit",20,null],[8,"InputIter","","abstracts common iteration operations on the input type",null,null],[16,"Item","","",21,null],[16,"RawItem","","",21,null],[16,"Iter","","",21,null],[16,"IterElem","","",21,null],[10,"iter_indices","","returns an iterator over the elements and their byte offsets",21,null],[10,"iter_elements","","returns an iterator over the elements",21,null],[10,"position","","finds the byte position of the element",21,null],[10,"slice_index","","get the byte offset from the element&#39;s position in the stream",21,null],[8,"InputTake","","abstracts slicing operations",null,null],[10,"take","","returns a slice of `count` bytes",22,null],[10,"take_split","","split the stream at the `count` byte offset",22,null],[8,"Compare","","abstracts comparison operations",null,null],[10,"compare","","compares self to another value for equality",23,null],[10,"compare_no_case","","compares self to another value for equality\nindependently of the case.",23,null],[8,"FindToken","","look for self in the given input stream",null,null],[10,"find_token","","",24,null],[8,"FindSubstring","","look for a substring in self",null,null],[10,"find_substring","","",25,null],[8,"ParseTo","","abstract method to calculate the input length",null,null],[10,"parse_to","","",26,null],[8,"Slice","","slicing operations using ranges",null,null],[10,"slice","","",27,null],[8,"GetInput","","",null,null],[10,"remaining_input","","",28,null],[8,"GetOutput","","",null,null],[10,"output","","",29,null],[8,"Consumer","","The Consumer trait wraps a computation and its state",null,null],[10,"handle","","implement handle for the current computation, returning the new state of the consumer",30,null],[10,"state","","returns the current state",30,null],[8,"Producer","","The producer wraps a data source, like file or network, and applies a consumer on it",null,null],[10,"apply","","Applies a consumer once on the produced data, and return the consumer&#39;s state",31,null],[11,"run","","Applies a consumer once on the produced data, and returns the generated value if there is one",31,null],[14,"dbg","","Prints a message if the parser fails",null,null],[14,"dbg_dmp","","Prints a message and the input if the parser fails",null,null],[14,"fix_error","","translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type",null,null],[14,"flat_map","","`flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;`",null,null],[14,"error_code","","creates a parse error from a `nom::ErrorKind`",null,null],[14,"error_node","","creates a parse error from a `nom::ErrorKind`\nand the next error in the parsing tree.\nif &quot;verbose-errors&quot; is not activated,\nit default to only the error code",null,null],[14,"error_position","","creates a parse error from a `nom::ErrorKind`\nand the position in the input\nif &quot;verbose-errors&quot; is not activated,\nit default to only the error code",null,null],[14,"error_node_position","","creates a parse error from a `nom::ErrorKind`,\nthe position in the input and the next error in\nthe parsing tree.\nif &quot;verbose-errors&quot; is not activated,\nit default to only the error code",null,null],[14,"closure","","Wraps a parser in a closure",null,null],[14,"named","","Makes a function from a parser combination",null,null],[14,"named_args","","Makes a function from a parser combination with arguments.",null,null],[14,"named_attr","","Makes a function from a parser combination, with attributes",null,null],[14,"call","","Used to wrap common expressions and function as macros",null,null],[14,"apply","","emulate function currying: `apply!(my_function, arg1, arg2, ...)` becomes `my_function(input, arg1, arg2, ...)`",null,null],[14,"return_error","","Prevents backtracking if the child parser fails",null,null],[14,"add_return_error","","Add an error if the child parser fails",null,null],[14,"complete","","replaces a `Incomplete` returned by the child parser\nwith an `Error`",null,null],[14,"try_parse","","A bit like `std::try!`, this macro will return the remaining input and parsed value if the child parser returned `Done`,\nand will do an early return for `Error` and `Incomplete`\nthis can provide more flexibility than `do_parse!` if needed",null,null],[14,"map","","`map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function on the result of a parser",null,null],[14,"map_res","","`map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function returning a Result on the output of a parser",null,null],[14,"map_opt","","`map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;`\nmaps a function returning an Option on the output of a parser",null,null],[14,"parse_to","","`parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;`\nuses the `parse` method from `std::str::FromStr` to convert the current\ninput to the specified type",null,null],[14,"verify","","`verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns the result of the child parser if it satisfies a verifcation function",null,null],[14,"value","","`value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;`",null,null],[14,"expr_res","","`expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nevaluate an expression that returns a Result&lt;T,E&gt; and returns a IResult::Done(I,T) if Ok",null,null],[14,"expr_opt","","`expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nevaluate an expression that returns a Option&lt;T&gt; and returns a IResult::Done(I,T) if Some",null,null],[14,"opt","","`opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nmake the underlying parser optional",null,null],[14,"opt_res","","`opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;`\nmake the underlying parser optional",null,null],[14,"cond_with_error","","`cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nConditional combinator",null,null],[14,"cond","","`cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;`\nConditional combinator",null,null],[14,"cond_reduce","","`cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nConditional combinator with error",null,null],[14,"peek","","`peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns a result without consuming the input",null,null],[14,"not","","`not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nreturns a result only if the embedded parser returns Error or Incomplete\ndoes not consume the input",null,null],[14,"tap","","`tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;`\nallows access to the parser&#39;s result without affecting it",null,null],[14,"eof","","`eof!(i)` returns `i` if it is at the end of input data",null,null],[14,"recognize","","`recognize!(&amp;[T] -&gt; IResult&lt;&amp;[T], O&gt; ) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nif the child parser was successful, return the consumed input as produced value",null,null],[14,"alt","","`alt!(I -&gt; IResult&lt;I,O&gt; | I -&gt; IResult&lt;I,O&gt; | ... | I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;`\ntry a list of parsers, return the result of the first successful one",null,null],[14,"alt_complete","","This is a combination of the `alt!` and `complete!` combinators. Rather\nthan returning `Incomplete` on partial input, `alt_complete!` will try the\nnext alternative in the chain. You should use this only if you know you\nwill not receive partial input for the rules you&#39;re trying to match (this\nis almost always the case for parsing programming languages).",null,null],[14,"switch","","`switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;`\nchoose the next parser depending on the result of the first one, if successful,\nand returns the result of the second parser",null,null],[14,"permutation","","",null,null],[14,"chain","","[DEPRECATED] `chain!(I-&gt;IResult&lt;I,A&gt; ~ I-&gt;IResult&lt;I,B&gt; ~ ... I-&gt;IResult&lt;I,X&gt; , || { return O } ) =&gt; I -&gt; IResult&lt;I, O&gt;`\nchains parsers and assemble the results through a closure",null,null],[14,"tuple","","`tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;`\nchains parsers and assemble the sub results in a tuple.",null,null],[14,"pair","","`pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;`\npair(X,Y), returns (x,y)",null,null],[14,"separated_pair","","`separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;`\nseparated_pair(X,sep,Y) returns (x,y)",null,null],[14,"preceded","","`preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\npreceded(opening, X) returns X",null,null],[14,"terminated","","`terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\nterminated(X, closing) returns X",null,null],[14,"delimited","","`delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`\ndelimited(opening, X, closing) returns X",null,null],[14,"do_parse","","`do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;`\ndo_parse applies sub parsers in a sequence.\nit can store intermediary results and make them available\nfor later parsers",null,null],[14,"separated_list","","`separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nseparated_list(sep, X) returns Vec&lt;X&gt;",null,null],[14,"separated_nonempty_list","","`separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nseparated_nonempty_list(sep, X) returns Vec&lt;X&gt;",null,null],[14,"many0","","`many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser 0 or more times and returns the list of results in a Vec",null,null],[14,"many1","","`many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"many_till","","`many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;`\nApplies the first parser until the second applies. Returns a tuple containing the list\nof results from the first in a Vec and the result of the second.",null,null],[14,"many_m_n","","`many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the parser between m and n times (n included) and returns the list of\nresults in a Vec",null,null],[14,"count","","`count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\nApplies the child parser a specified number of times",null,null],[14,"count_fixed","","`count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;`\nApplies the child parser a fixed number of times and returns a fixed size array\nThe type must be specified and it must be `Copy`",null,null],[14,"length_count","","`length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\ngets a number from the first parser, then applies the second parser that many times",null,null],[14,"length_data","","`length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O`",null,null],[14,"length_value","","`length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;`\ngets a number from the first parser, takes a subslice of the input of that size,\nthen applies the second parser on that subslice. If the second parser returns\n`Incomplete`, `length_value` will return an error",null,null],[14,"fold_many0","","`fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser 0 or more times and folds the list of return values",null,null],[14,"fold_many1","","`fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser 1 or more times and folds the list of return values",null,null],[14,"fold_many_m_n","","`fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;`\nApplies the parser between m and n times (n included) and folds the list of return value",null,null],[14,"method","","Makes a method from a parser combination",null,null],[14,"call_m","","Used to called methods then move self back into self",null,null],[14,"apply_m","","emulate function currying for method calls on structs\n`apply_m!(self.my_function, arg1, arg2, ...)` becomes `self.my_function(input, arg1, arg2, ...)`",null,null],[14,"tag","","`tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ndeclares a byte array as a suite to recognize",null,null],[14,"tag_no_case","","`tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ndeclares a case insensitive ascii string as a suite to recognize",null,null],[14,"is_not","","`is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes that do not appear in the provided array",null,null],[14,"is_a","","`is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes that appear in the provided array",null,null],[14,"escaped","","`escaped!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nmatches a byte string with escaped characters.",null,null],[14,"escaped_transform","","`escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;`\nmatches a byte string with escaped characters.",null,null],[14,"take_while","","`take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes until the provided function fails.",null,null],[14,"take_while1","","`take_while1!(&amp;[T] -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest (non empty) list of bytes until the provided function fails.",null,null],[14,"take_till","","`take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nreturns the longest list of bytes until the provided function succeeds",null,null],[14,"take","","`take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"take_str","","`take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;`\nsame as take! but returning a &amp;str",null,null],[14,"take_until_and_consume","","`take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\ngenerates a parser consuming bytes until the specified byte sequence is found, and consumes it",null,null],[14,"take_until","","`take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nconsumes data until it finds the specified tag",null,null],[14,"take_until_either_and_consume","","`take_until_either_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nconsumes data until it finds any of the specified characters, and consume it",null,null],[14,"take_until_either","","`take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`",null,null],[14,"length_bytes","","`length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;`\nGets a number from the first parser, then extracts that many bytes from the\nremaining stream",null,null],[14,"bits","","`bits!( parser ) =&gt; ( &amp;[u8], (&amp;[u8], usize) -&gt; IResult&lt;(&amp;[u8], usize), T&gt; ) -&gt; IResult&lt;&amp;[u8], T&gt;`\ntransforms its byte slice input into a bit stream for the underlying parsers",null,null],[14,"take_bits","","`take_bits!(type, nb) =&gt; ( (&amp;[T], usize), U, usize) -&gt; IResult&lt;(&amp;[T], usize), U&gt;`\ngenerates a parser consuming the specified number of bits.",null,null],[14,"tag_bits","","matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified",null,null],[14,"u16","","if the parameter is nom::Endianness::Big, parse a big endian u16 integer,\notherwise a little endian u16 integer",null,null],[14,"u32","","if the parameter is nom::Endianness::Big, parse a big endian u32 integer,\notherwise a little endian u32 integer",null,null],[14,"u64","","if the parameter is nom::Endianness::Big, parse a big endian u64 integer,\notherwise a little endian u64 integer",null,null],[14,"i16","","if the parameter is nom::Endianness::Big, parse a big endian i16 integer,\notherwise a little endian i16 integer",null,null],[14,"i32","","if the parameter is nom::Endianness::Big, parse a big endian i32 integer,\notherwise a little endian i32 integer",null,null],[14,"i64","","if the parameter is nom::Endianness::Big, parse a big endian i64 integer,\notherwise a little endian i64 integer",null,null],[14,"one_of","","matches one of the provided characters",null,null],[14,"none_of","","matches anything but the provided characters",null,null],[14,"char","","matches one character: `char!(char) =&gt; &amp;[u8] -&gt; IResult&lt;&amp;[u8], char&gt;",null,null],[14,"wrap_sep","","",null,null],[14,"eat_separator","","helper macros to build a separator parser",null,null],[14,"sep","","sep is the parser rewriting macro for whitespace separated formats",null,null],[14,"ws","","`ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;`",null,null],[14,"consumer_from_parser","","",null,null],[14,"tag_s","","`tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ndeclares a string as a suite to recognize",null,null],[14,"tag_no_case_s","","`tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ndeclares a case-insensitive string as a suite to recognize",null,null],[14,"take_s","","`take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming the specified number of characters",null,null],[14,"is_not_s","","`is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters that do not appear in the provided array",null,null],[14,"is_a_s","","`is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters that appear in the provided array",null,null],[14,"take_while_s","","`take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters until the provided function fails.",null,null],[14,"take_while1_s","","`take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest (non empty) list of characters until the provided function fails.",null,null],[14,"take_till_s","","`take_till_s!(&amp;str -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\nreturns the longest list of characters until the provided function succeeds",null,null],[14,"take_until_and_consume_s","","`take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming all chars until the specified string is found and consumes it",null,null],[14,"take_until_s","","`take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;`\ngenerates a parser consuming all chars until the specified string is found and leaves it in the remaining input",null,null],[11,"run","","Applies a consumer once on the produced data, and returns the generated value if there is one",31,null]],"paths":[[4,"ErrorKind"],[4,"CompareResult"],[4,"Needed"],[4,"IResult"],[4,"IError"],[4,"Endianness"],[4,"Input"],[4,"ConsumerState"],[4,"Move"],[4,"FileProducerState"],[6,"Err"],[3,"ProducerRepeat"],[3,"MemProducer"],[3,"FileProducer"],[3,"MapConsumer"],[3,"ChainConsumer"],[8,"Offset"],[8,"HexDisplay"],[8,"AsBytes"],[8,"InputLength"],[8,"AsChar"],[8,"InputIter"],[8,"InputTake"],[8,"Compare"],[8,"FindToken"],[8,"FindSubstring"],[8,"ParseTo"],[8,"Slice"],[8,"GetInput"],[8,"GetOutput"],[8,"Consumer"],[8,"Producer"]]};
initSearch(searchIndex);
